--- src/cmd/ksh93/bltins/cd_pwd.c	2013-06-26 22:12:28.000000000 +0200
+++ src/cmd/ksh93/bltins/cd_pwd.c	2013-07-08 14:33:26.036807579 +0200
@@ -55,9 +55,17 @@
  */
 int sh_diropenat(Shell_t *shp, int dir, const char *path, bool xattr)
 {
+#ifdef O_DIRECTORY
+#define O_directory (O_DIRECTORY)
+#else
+#define O_directory (0)
+#endif
+
 	int fd,shfd;
-	int savederrno=errno;
+	int savederrno;
+#ifndef O_DIRECTORY
 	struct stat fs;
+#endif
 #ifndef O_XATTR
 	NOT_USED(xattr);
 #endif
@@ -70,24 +78,59 @@
 		if((apfd = openat(dir, path, O_RDONLY|O_NONBLOCK|O_cloexec))>=0)
 		{
 			fd = openat(apfd, e_dot, O_XATTR|O_cloexec);
+			savederrno=errno;
 			close(apfd);
+			errno=savederrno;
+		}
+		else
+		{
+			return -1;
 		}
 	}
 	else
 #endif
-		fd = openat(dir, path, O_SEARCH|O_NONBLOCK|O_cloexec);
+	{
+		/*
+		 * Open directory. First we try without |O_SEARCH| and
+		 * if this fails with EACCESS we try with |O_SEARCH|
+		 * again.
+		 * This is required ...
+		 * - ... because some platforms may require that it can
+		 * only be used for directories while some filesystems
+		 * (e.g. Reiser4 or HSM systems) allow a |fchdir()| into
+		 * files, too)
+		 * - ... to preserve the semantics of "cd", e.g.
+		 * otherwise "cd" would return [No access] instead of
+		 * [Not a directory] for files on filesystems which do
+		 * not allow a "cd" into files.
+		 * - ... to allow that a
+		 * $ redirect {n}</etc ; cd /dev/fd/$n # works on most
+		 * platforms.
+		 */
+
+		fd = openat(dir, path, O_directory|O_NONBLOCK|O_cloexec);
+		if ((fd < 0) && (errno == EACCES))
+		{
+			fd = openat(dir, path, O_SEARCH|O_directory|O_NONBLOCK|O_cloexec);
+		}
+	}
 
 	if(fd < 0)
+	{
 		return fd;
+	}
+
+#ifndef O_DIRECTORY
 	if (!fstat(fd, &fs) && !S_ISDIR(fs.st_mode))
 	{
 		close(fd);
 		errno = ENOTDIR;
 		return -1;
 	}
+#endif
 
 	/* Move fd to a number > 10 and register the fd number with the shell */
-	shfd = fcntl(fd, F_dupfd_cloexec, 10);
+	shfd = sh_fcntl(fd, F_dupfd_cloexec, 10);
 	savederrno=errno;
 	close(fd);
 	errno=savederrno;
@@ -149,7 +192,7 @@
 	register Shell_t *shp = context->shp;
 	int saverrno=0;
 	int rval;
-	bool flag=false,xattr=false, use_devfd=false;
+	bool pflag=false,xattr=false, use_devfd=false;
 	char *oldpwd,*cp;
 	struct stat statb;
 	int dirfd = shp->pwdfd;
@@ -164,10 +207,10 @@
 			dirfd = opt_info.num;
 			break;
 		case 'L':
-			flag = false;
+			pflag = false;
 			break;
 		case 'P':
-			flag = true;
+			pflag = true;
 			break;
 #ifdef O_XATTR
 		case '@':
@@ -283,7 +326,7 @@
 			stakputs(last+PATH_OFFSET);
 			stakputc(0);
 		}
-		if(!flag)
+		if(!pflag)
 		{
 			register char *cp;
 			stakseek(PATH_MAX+PATH_OFFSET);
@@ -329,11 +372,7 @@
 				if(shp->pwdfd >= 0)
 				{
 					sh_close(shp->pwdfd);
-#ifdef AT_FDCWD
 					shp->pwdfd = AT_FDCWD;
-#else
-					shp->pwdfd = -1;
-#endif
 				}
 			}
 		}
@@ -399,7 +438,7 @@
 #   endif
 #endif
 	}
-	else if(flag)
+	else if(pflag)
 	{
 		dir = stakptr(PATH_OFFSET);
 		if (!(dir=pathcanon(dir,PATH_MAX,PATH_PHYSICAL)))
@@ -415,10 +454,10 @@
 	if(*dir != '/')
 		return(0);
 	nv_putval(opwdnod,oldpwd,NV_RDONLY);
-	flag = (strlen(dir)>0)?true:false;
+	pflag = (strlen(dir)>0)?true:false;
 	/* delete trailing '/' */
-	while(--flag>0 && dir[flag]=='/')
-		dir[flag] = 0;
+	while(--pflag>0 && dir[(int)pflag]=='/')
+		dir[(int)pflag] = 0;
 	nv_putval(pwdnod,dir,NV_RDONLY);
 	nv_onattr(pwdnod,NV_NOFREE|NV_EXPORT);
 	shp->pwd = pwdnod->nvalue.cp;